<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UriBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">http-builder-ng</a> &gt; <a href="index.source.html" class="el_package">groovyx.net.http</a> &gt; <span class="el_source">UriBuilder.java</span></div><h1>UriBuilder.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2017 HttpBuilder-NG Project
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package groovyx.net.http;

import groovy.lang.GString;
import org.codehaus.groovy.runtime.GStringImpl;

import java.io.IOException;
import java.net.HttpCookie;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static groovyx.net.http.Traverser.notValue;
import static groovyx.net.http.Traverser.traverse;
import static java.lang.String.format;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.Collections.singletonList;

/**
 * Provides a simple means of creating a request URI and optionally overriding its parts.
 *
 * [source,groovy]
 * ----
 * def uri = UriBuilder.basic(UriBuilder.root())
 * .setFull('http://localhost:10101')
 * .setPath('/foo')
 * .toURI()
 * ----
 *
 * Generally, this class is not instantiated directly, but created by the {@link HttpConfig} instance and modified.
 */
<span class="fc" id="L49">public abstract class UriBuilder {</span>

    public static final int DEFAULT_PORT = -1;

    /**
     * Sets the scheme part of the URI.
     *
     * @param val the value to use as the scheme part of the URI
     * @return a reference to this builder
     */
    public abstract UriBuilder setScheme(String val);

    /**
     * Retrieves the scheme part of the URI.
     *
     * @return the URI scheme
     */
    public abstract String getScheme();

    /**
     * Sets the port part of the URI.
     *
     * @param val the value to use as the port part of the URI
     * @return a reference to this builder
     */
    public abstract UriBuilder setPort(int val);

    /**
     * Retrieves the port part of the URI.
     *
     * @return the port part of the URI
     */
    public abstract int getPort();

    /**
     * Sets the host part of the URI.
     *
     * @param val the value to use as the host part of the URI
     * @return a reference to this builder
     */
    public abstract UriBuilder setHost(String val);

    /**
     * Retrieves the host part of the URI.
     *
     * @return the host part of the URI
     */
    public abstract String getHost();

    /**
     * Sets the path part of the URI.
     *
     * @param val the path part of the URI
     * @return a reference to the builder
     */
    public abstract UriBuilder setPath(GString val);

    /**
     * Retrieves the path part of the URI.
     *
     * @return the path part of the URI
     */
    public abstract GString getPath();

    /**
     * Sets the query string part of the `URI` from the provided map. The query string key-value pairs will be generated from the key-value pairs
     * of the map and are NOT URL-encoded. Nested maps or other data structures are not supported.
     *
     * @param val the map of query string parameters
     * @return a reference to the builder
     */
    public abstract UriBuilder setQuery(Map&lt;String, ?&gt; val);

    /**
     * Retrieves the `Map` of query string parameters for the `URI`.
     *
     * @return the `Map` of query string parameters for the `URI`.
     */
    public abstract Map&lt;String, ?&gt; getQuery();

    /**
     * Sets the fragment part of the `URI`.
     *
     * @param val the fragment part of the `URI`
     * @return a reference to the builder
     */
    public abstract UriBuilder setFragment(String val);

    /**
     * Retrieves the fragment part of the `URI`.
     *
     * @return the fragment part of the `URI`
     */
    public abstract String getFragment();

    /**
     * Sets the user info part of the `URI`.
     *
     * @param val the user info part of the `URI`
     * @return a reference to the builder
     */
    public abstract UriBuilder setUserInfo(String val);

    /**
     * Retrieves the user info part of the `URI`.
     *
     * @return the user info part of the `URI`
     */
    public abstract String getUserInfo();

    public abstract UriBuilder getParent();

    /**
     * Sets the path part of the URI.
     *
     * @param str the path part of the URI
     * @return a reference to the builder
     */
    public UriBuilder setPath(final String str) {
        final String[] parts;
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (str.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L170">            parts = new String[]{str};</span>
        } else {
<span class="fc" id="L172">            final String base = getPath().toString();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            parts = new String[]{base, base.endsWith(&quot;/&quot;) ? &quot;&quot; : &quot;/&quot;, str};</span>
        }

<span class="fc" id="L176">        return setPath(new GStringImpl(EMPTY, parts));</span>
    }

    public URI forCookie(final HttpCookie cookie) throws URISyntaxException {
<span class="fc" id="L180">        final String scheme = traverse(this, UriBuilder::getParent, UriBuilder::getScheme, Traverser::notNull);</span>
<span class="fc" id="L181">        final Integer port = traverse(this, UriBuilder::getParent, UriBuilder::getPort, notValue(DEFAULT_PORT));</span>
<span class="fc" id="L182">        final String host = traverse(this, UriBuilder::getParent, UriBuilder::getHost, Traverser::notNull);</span>
<span class="fc" id="L183">        final String path = cookie.getPath();</span>
<span class="fc" id="L184">        final String query = null;</span>
<span class="fc" id="L185">        final String fragment = null;</span>
<span class="fc" id="L186">        final String userInfo = null;</span>

<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        return new URI(scheme, userInfo, host, (port == null ? -1 : port), path, query, fragment);</span>
    }

    /**
     * Converts the parts of the `UriBuilder` to the `URI` object instance.
     *
     * @return the generated `URI` representing the parts contained in the builder
     */
    public URI toURI() throws URISyntaxException {
<span class="fc" id="L197">        final String scheme = traverse(this, UriBuilder::getParent, UriBuilder::getScheme, Traverser::notNull);</span>
<span class="fc" id="L198">        final Integer port = traverse(this, UriBuilder::getParent, UriBuilder::getPort, notValue(DEFAULT_PORT));</span>
<span class="fc" id="L199">        final String host = traverse(this, UriBuilder::getParent, UriBuilder::getHost, Traverser::notNull);</span>
<span class="fc" id="L200">        final GString path = traverse(this, UriBuilder::getParent, UriBuilder::getPath, Traverser::notNull);</span>
<span class="fc" id="L201">        final String query = populateQueryString(traverse(this, UriBuilder::getParent, UriBuilder::getQuery, Traverser::nonEmptyMap));</span>
<span class="fc" id="L202">        final String fragment = traverse(this, UriBuilder::getParent, UriBuilder::getFragment, Traverser::notNull);</span>
<span class="fc" id="L203">        final String userInfo = traverse(this, UriBuilder::getParent, UriBuilder::getUserInfo, Traverser::notNull);</span>
<span class="fc" id="L204">        final Boolean useRaw = traverse(this, UriBuilder::getParent, UriBuilder::getUseRawValues, Traverser::notNull);</span>

<span class="pc bpc" id="L206" title="1 of 4 branches missed.">        if (useRaw != null &amp;&amp; useRaw) {</span>
<span class="fc" id="L207">            return toRawURI(scheme, port, host, path, query, fragment, userInfo);</span>
        } else {
<span class="fc bfc" id="L209" title="All 4 branches covered.">            return new URI(scheme, userInfo, host, (port == null ? -1 : port), ((path == null) ? null : path.toString()), query, fragment);</span>
        }
    }

    private URI toRawURI(final String scheme, final Integer port, final String host, final GString path, final String query, final String fragment, final String userInfo) throws URISyntaxException {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        return new URI(format(&quot;%s%s%s%s%s%s%s&quot;,</span>
<span class="pc bpc" id="L215" title="2 of 4 branches missed.">            scheme == null ? &quot;&quot; : (scheme.endsWith(&quot;://&quot;) ? scheme : scheme + &quot;://&quot;),</span>
<span class="pc bpc" id="L216" title="4 of 6 branches missed.">            userInfo == null ? &quot;&quot; : (userInfo.endsWith(&quot;@&quot;) ? userInfo : userInfo + &quot;@&quot;),</span>
            host == null ? &quot;&quot; : host,
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">            port == null ? &quot;&quot; : &quot;:&quot; + port.toString(),</span>
<span class="pc bpc" id="L219" title="4 of 8 branches missed.">            path == null ? &quot;&quot; : (!path.toString().startsWith(&quot;/&quot;) &amp;&amp; !path.toString().isEmpty() ? &quot;/&quot; + path : path),</span>
            query != null ? &quot;?&quot; + query : &quot;&quot;,
<span class="pc bnc" id="L221" title="All 2 branches missed.">            fragment == null ? &quot;&quot; : (!fragment.startsWith(&quot;#&quot;) ? &quot;#&quot; + fragment : fragment)</span>
        ));
    }

<span class="fc" id="L225">    private static final Object[] EMPTY = new Object[0];</span>

    private static String populateQueryString(final Map&lt;String, ?&gt; queryMap) {
<span class="pc bpc" id="L228" title="1 of 4 branches missed.">        if (queryMap == null || queryMap.isEmpty()) {</span>
<span class="fc" id="L229">            return null;</span>

        } else {
<span class="fc" id="L232">            final List&lt;String&gt; nvps = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L234">            queryMap.entrySet().forEach((Consumer&lt;Map.Entry&lt;String, ?&gt;&gt;) entry -&gt; {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">                final Collection&lt;?&gt; values = entry.getValue() instanceof Collection ? (Collection&lt;?&gt;) entry.getValue() : singletonList(entry.getValue().toString());</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">                if(values.isEmpty()){</span>
<span class="fc" id="L237">                    nvps.add(entry.getKey());</span>
                } else {
<span class="fc" id="L239">                    values.forEach(value -&gt; nvps.add(entry.getKey() + &quot;=&quot; + value));</span>
                }
<span class="fc" id="L241">            });</span>

<span class="fc" id="L243">            return nvps.stream().collect(Collectors.joining(&quot;&amp;&quot;));</span>
        }
    }

    private Boolean useRawValues;

    public void setUseRawValues(final boolean useRaw) {
<span class="fc" id="L250">        this.useRawValues = useRaw;</span>
<span class="fc" id="L251">    }</span>

    public Boolean getUseRawValues() {
<span class="fc" id="L254">        return useRawValues;</span>
    }

    protected final void populateFrom(final URI uri) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">        boolean useRaw = useRawValues != null ? useRawValues : false;</span>

        try {
<span class="fc" id="L261">            setScheme(uri.getScheme());</span>
<span class="fc" id="L262">            setPort(uri.getPort());</span>
<span class="fc" id="L263">            setHost(uri.getHost());</span>

<span class="fc bfc" id="L265" title="All 2 branches covered.">            final String path = useRaw ? uri.getRawPath() : uri.getPath();</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">            if (path != null) {</span>
<span class="fc" id="L267">                setPath(new GStringImpl(EMPTY, new String[]{path}));</span>
            }

<span class="fc bfc" id="L270" title="All 2 branches covered.">            final String rawQuery = useRaw ? uri.getRawQuery() : uri.getQuery();</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">            if (rawQuery != null) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (useRaw) {</span>
<span class="fc" id="L273">                    setQuery(extractQueryMap(rawQuery));</span>
                } else {
<span class="fc" id="L275">                    setQuery(Form.decode(new StringBuilder(rawQuery), UTF_8));</span>
                }
            }

<span class="fc bfc" id="L279" title="All 2 branches covered.">            setFragment(useRaw ? uri.getRawFragment() : uri.getFragment());</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            setUserInfo(useRaw ? uri.getRawUserInfo() : uri.getUserInfo());</span>
<span class="nc" id="L281">        } catch (IOException e) {</span>
            //this seems o.k. to just convert to a runtime exception,
            //we started with a valid URI, so this should never happen.
<span class="nc" id="L284">            throw new RuntimeException(e);</span>
<span class="fc" id="L285">        }</span>
<span class="fc" id="L286">    }</span>

    // does not do any encoding
    private static Map&lt;String, Collection&lt;String&gt;&gt; extractQueryMap(final String queryString) {
<span class="fc" id="L290">        final Map&lt;String, Collection&lt;String&gt;&gt; map = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (final String nvp : queryString.split(&quot;&amp;&quot;)) {</span>
<span class="fc" id="L293">            final String[] pair = nvp.split(&quot;=&quot;);</span>
<span class="fc" id="L294">            map.computeIfAbsent(pair[0], k -&gt; {</span>
<span class="fc" id="L295">                List&lt;String&gt; list = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L296">                list.add(pair[1]);</span>
<span class="fc" id="L297">                return list;</span>
            });
        }

<span class="fc" id="L301">        return map;</span>
    }

    /**
     * Sets the full URI (all parts) as a String.
     *
     * @param str the full URI to be used by the `UriBuilder`
     * @return a reference to the builder
     * @throws IllegalArgumentException if there is a problem with the URI syntax
     */
    public final UriBuilder setFull(final String str) {
        try {
<span class="fc" id="L313">            return setFull(new URI(str));</span>
<span class="nc" id="L314">        } catch (URISyntaxException ex) {</span>
<span class="nc" id="L315">            throw new IllegalArgumentException(ex.getMessage());</span>
        }
    }

    /**
     * Sets the full URI (all parts) as a URI object.
     *
     * @param uri the full URI to be used by the `UriBuilder`
     * @return a reference to the builder
     */
    public final UriBuilder setFull(final URI uri) {
<span class="fc" id="L326">        populateFrom(uri);</span>
<span class="fc" id="L327">        return this;</span>
    }

    /**
     * Creates a basic `UriBuilder` from the provided parent builder. An empty `UriBuilder` may be created using the `root()` method as the `parent` value,
     * otherwise a new `UriBuilder` may be created from an existing builder:
     *
     * [source,groovy]
     * ----
     * def parent = UriBuilder.basic(UriBuilder.root()).setFull('http://localhost:10101/foo')
     * def child = UriBuilder.basic(parent)
     * child.setPath('/bar').toURI() == new URI('http://localhost:10101/bar')
     * ----
     *
     * The `UriBuilder` implementation generated with this method is _not_ thread-safe.
     *
     * @param parent the `UriBuilder` parent
     * @return the created `UriBuilder`
     */
    public static UriBuilder basic(final UriBuilder parent) {
<span class="fc" id="L347">        return new Basic(parent);</span>
    }

    /**
     * Creates a thread-safe `UriBuilder` from the provided parent builder. An empty `UriBuilder` may be created using the `root()` method as the
     * `parent` value, otherwise a new `UriBuilder` may be created from an existing builder:
     *
     * [source,groovy]
     * ----
     * def parent = UriBuilder.threadSafe(UriBuilder.root()).setFull('http://localhost:10101/foo')
     * def child = UriBuilder.threadSafe(parent)
     * child.setPath('/bar').toURI() == new URI('http://localhost:10101/bar')
     * ----
     *
     * The `UriBuilder` implementation generated with this method is thread-safe.
     *
     * @param parent the `UriBuilder` parent
     * @return the created `UriBuilder`
     */
    public static UriBuilder threadSafe(final UriBuilder parent) {
<span class="fc" id="L367">        return new ThreadSafe(parent);</span>
    }

    public static UriBuilder root() {
<span class="fc" id="L371">        return new ThreadSafe(null);</span>
    }

    private static final class Basic extends UriBuilder {
        private String scheme;

        public UriBuilder setScheme(String val) {
<span class="fc" id="L378">            scheme = val;</span>
<span class="fc" id="L379">            return this;</span>
        }

        public String getScheme() {
<span class="fc" id="L383">            return scheme;</span>
        }

<span class="fc" id="L386">        private int port = DEFAULT_PORT;</span>

        public UriBuilder setPort(int val) {
<span class="fc" id="L389">            port = val;</span>
<span class="fc" id="L390">            return this;</span>
        }

        public int getPort() {
<span class="fc" id="L394">            return port;</span>
        }

        private String host;

        public UriBuilder setHost(String val) {
<span class="fc" id="L400">            host = val;</span>
<span class="fc" id="L401">            return this;</span>
        }

        public String getHost() {
<span class="fc" id="L405">            return host;</span>
        }

        private GString path;

        public UriBuilder setPath(GString val) {
<span class="fc" id="L411">            path = val;</span>
<span class="fc" id="L412">            return this;</span>
        }

        public GString getPath() {
<span class="fc" id="L416">            return path;</span>
        }

<span class="fc" id="L419">        private Map&lt;String, Object&gt; query = new LinkedHashMap&lt;&gt;(1);</span>

        public UriBuilder setQuery(final Map&lt;String, ?&gt; val) {
<span class="fc bfc" id="L422" title="All 2 branches covered.">            if (val != null) {</span>
<span class="fc" id="L423">                query.putAll(val);</span>
            }
<span class="fc" id="L425">            return this;</span>
        }

        public Map&lt;String, Object&gt; getQuery() {
<span class="fc" id="L429">            return query;</span>
        }

        private String fragment;

        public UriBuilder setFragment(String val) {
<span class="fc" id="L435">            fragment = val;</span>
<span class="fc" id="L436">            return this;</span>
        }

        public String getFragment() {
<span class="fc" id="L440">            return fragment;</span>
        }

        private String userInfo;

        public UriBuilder setUserInfo(String val) {
<span class="fc" id="L446">            userInfo = val;</span>
<span class="fc" id="L447">            return this;</span>
        }

        public String getUserInfo() {
<span class="fc" id="L451">            return userInfo;</span>
        }

        private final UriBuilder parent;

        public UriBuilder getParent() {
<span class="fc" id="L457">            return parent;</span>
        }

<span class="fc" id="L460">        public Basic(final UriBuilder parent) {</span>
<span class="fc" id="L461">            this.parent = parent;</span>
<span class="fc" id="L462">        }</span>
    }

    private static final class ThreadSafe extends UriBuilder {
        private volatile String scheme;

        public UriBuilder setScheme(String val) {
<span class="fc" id="L469">            scheme = val;</span>
<span class="fc" id="L470">            return this;</span>
        }

        public String getScheme() {
<span class="fc" id="L474">            return scheme;</span>
        }

<span class="fc" id="L477">        private volatile int port = DEFAULT_PORT;</span>

        public UriBuilder setPort(int val) {
<span class="fc" id="L480">            port = val;</span>
<span class="fc" id="L481">            return this;</span>
        }

        public int getPort() {
<span class="fc" id="L485">            return port;</span>
        }

        private volatile String host;

        public UriBuilder setHost(String val) {
<span class="fc" id="L491">            host = val;</span>
<span class="fc" id="L492">            return this;</span>
        }

        public String getHost() {
<span class="fc" id="L496">            return host;</span>
        }

        private volatile GString path;

        public UriBuilder setPath(GString val) {
<span class="fc" id="L502">            path = val;</span>
<span class="fc" id="L503">            return this;</span>
        }

        public GString getPath() {
<span class="fc" id="L507">            return path;</span>
        }

<span class="fc" id="L510">        private Map&lt;String, Object&gt; query = new ConcurrentHashMap&lt;&gt;();</span>

        public UriBuilder setQuery(Map&lt;String, ?&gt; val) {
<span class="fc" id="L513">            query.putAll(val);</span>
<span class="fc" id="L514">            return this;</span>
        }

        public Map&lt;String, ?&gt; getQuery() {
<span class="fc" id="L518">            return query;</span>
        }

        private volatile String fragment;

        public UriBuilder setFragment(String val) {
<span class="fc" id="L524">            fragment = val;</span>
<span class="fc" id="L525">            return this;</span>
        }

        public String getFragment() {
<span class="fc" id="L529">            return fragment;</span>
        }

        private volatile String userInfo;

        public UriBuilder setUserInfo(String val) {
<span class="fc" id="L535">            userInfo = val;</span>
<span class="fc" id="L536">            return this;</span>
        }

        public String getUserInfo() {
<span class="fc" id="L540">            return userInfo;</span>
        }

        private final UriBuilder parent;

        public UriBuilder getParent() {
<span class="fc" id="L546">            return parent;</span>
        }

<span class="fc" id="L549">        public ThreadSafe(final UriBuilder parent) {</span>
<span class="fc" id="L550">            this.parent = parent;</span>
<span class="fc" id="L551">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>